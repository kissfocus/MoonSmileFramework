package com.apptech.base.security;

import com.apptech.base.identity.AuthToken;
import com.apptech.base.identity.AuthedUser;
import io.dropwizard.auth.AuthFilter;
import io.dropwizard.auth.AuthenticationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.ws.rs.WebApplicationException;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.SecurityContext;
import java.io.IOException;
import java.security.Principal;
import java.util.Optional;

public class FrameAuthFilter extends AuthFilter<FrameCredentials, AuthedUser> {

    private static final Logger LOGGER = LoggerFactory.getLogger(FrameAuthFilter.class);

    private static final String AUTHFAIL = "AuthFail";

    @Override
    public void filter(ContainerRequestContext requestContext) throws IOException {
        try {
            // Get the Authorization header
            // Here need to check the token is generated by server,now is not check
            final String header = requestContext.getHeaderString(HttpHeaders.AUTHORIZATION);
            if (header != null) {
                final Optional<AuthToken> authTokens = getAuthedToken(header);
                if (authTokens.isPresent()) {
                    final FrameCredentials credentials = new FrameCredentials(authTokens.get().getSignature());
                    final Optional<AuthedUser> result = authenticator.authenticate(credentials);
                    if (result.isPresent()) {
                        configSecurityContext(requestContext, result.get());
                        return;
                    }
                }
            }

        } catch (IllegalArgumentException e) {
            LOGGER.warn("Error decoding credentials", e);
        } catch (AuthenticationException e) {
            LOGGER.warn("Error authenticating credentials", e);
        } catch (Exception e) {
            LOGGER.warn("Error authenticating process", e);
        }

        // Must have failed to be here
        throw new WebApplicationException(Response.status(Response.Status.UNAUTHORIZED)
                .header(HttpHeaders.AUTHORIZATION, AUTHFAIL)
                .entity("Credentials are required to access this resource.")
                .type(MediaType.TEXT_PLAIN_TYPE)
                .build());
    }

    private void configSecurityContext(ContainerRequestContext requestContext, AuthedUser user) {
        requestContext.setSecurityContext(new SecurityContext() {
            @Override
            public Principal getUserPrincipal() {
                return user;
            }

            @Override
            public boolean isUserInRole(String role) {
                return authorizer.authorize(user, role);
            }

            @Override
            public boolean isSecure() {
                return requestContext.getSecurityContext().isSecure();
            }

            @Override
            public String getAuthenticationScheme() {
                return SecurityContext.FORM_AUTH;
            }
        });
    }

    private Optional<AuthToken> getAuthedToken(String header) {
        final String[] authTokens = header.split(" ");
        if (authTokens.length != 3) return Optional.empty();
        return Optional.of(new AuthToken(authTokens[0], authTokens[1], authTokens[2]));
    }

    public static class Builder extends
            AuthFilterBuilder<FrameCredentials, AuthedUser, FrameAuthFilter> {

        @Override
        protected FrameAuthFilter newInstance() {
            return new FrameAuthFilter();
        }
    }
}
